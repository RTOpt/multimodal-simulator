import pandas as pd
import numpy as np
import os
import json
import ast

def generate_test_instance(date: str,
                            route_ids,
                            start_time : int = 20000,
                            nbr_buses_per_route_id : int = 2,
                            base_path = os.path.join(os.path.dirname(__file__), '..', '..', 'data', 'fixed_line', 'gtfs')):
    """
    Generate a test instance for a given date and route_ids.
    The test instance is generated by filtering the GTFS files based on the selected route_ids, start_time, and nbr_buses_per_route_id.
    The connections are then filtered based on the selected stop_ids, and the requests are filtered based on the selected trip_ids.
    
    Inputs:
    - date: the date for which to generate the test instance (format: "YYYY-MM-DD")
    - route_ids: a list of route_ids to consider
    - start_time: the start time (in seconds from midnight) after which to consider trips
    - nbr_buses_per_route_id: the number of buses to consider for each route_id
    - base_path: the base path where the GTFS files are stored
    """

    # Filter GTFS files based on route_ids, time and number of buses
    filter_gtfs_files(route_ids, start_time, nbr_buses_per_route_id, base_path, date)

    # Filter connections based on selected stop_ids
    output_path = os.path.join(base_path, f"{date}-TestInstance")
    selected_stop_ids = pd.read_csv(os.path.join(output_path, "stops.txt"))['stop_id'].unique()
    input_path = os.path.join(base_path, date)
    filter_connections(input_path, output_path, selected_stop_ids)

    # Filter requests based on selected trip_ids
    selected_trips = pd.read_csv(os.path.join(output_path, "trips.txt"))['trip_id'].unique()
    filter_requests(date, selected_trips, base_path)

    print("Extraction complete. Output files generated:")
    # print(f"- {os.path.join(output_path, 'output_trips.txt')}")
    # print(f"- {os.path.join(output_path, 'output_stop_times_upgrade.txt')}")
    # print(f"- {os.path.join(output_path, 'output_stops.txt')}")
    # print(f"- {os.path.join(output_path, 'available_connections.json')}")
    # print(f"- {os.path.join(output_path, 'filtered_requests.csv')}")

def filter_gtfs_files(route_ids : list,
                      start_time : int ,
                      nbr_buses_per_route_id : int,
                      base_path : str,
                      date):
    """
    Filter GTFS files based on the selected route_ids, start_time, and nbr_buses_per_route_id.
    The filtered files are saved in a new directory named "{date}-TestInstance".

    Inputs:
    - route_ids: a list of route_ids to consider
    - start_time: the start time (in seconds from midnight) after which to consider trips
    - nbr_buses_per_route_id: the number of buses to consider for each route_id
    - base_path: the base path where the GTFS files are stored
    - date: the date for which to generate the test instance (format: "YYYY-MM-DD")
    """

    # Load input files
    input_path = os.path.join(base_path, date)
    stop_times_path = os.path.join(input_path, "stop_times_upgrade.txt")
    trips_path = os.path.join(input_path, "trips.txt")
    stops_path = os.path.join(input_path, "stops.txt")

    # Load GTFS data into dataframes
    stop_times_df = pd.read_csv(stop_times_path)
    trips_df = pd.read_csv(trips_path)
    stops_df = pd.read_csv(stops_path)
    # Step 1: Filter trips based on route_ids
    filtered_trips_df = trips_df[trips_df['route_id'].isin(route_ids)]

    # Step 2: For each route_id, select the first N trips after the start time H
    selected_trips = []
    for route_id in route_ids:
        # Get the trips for this route
        route_trips = filtered_trips_df[filtered_trips_df['route_id'] == route_id]
        
        # Get corresponding stop times for these trips
        stop_times_for_route = stop_times_df[stop_times_df['trip_id'].isin(route_trips['trip_id'])]
        
        # Sort stop times by planned_departure_time_from_origin and then by stop_sequence
        stop_times_for_route = stop_times_for_route.sort_values(by=['planned_departure_time_from_origin', 'stop_sequence'])
        
        # Filter stop times that have planned_departure_time_from_origin after H
        stop_times_after_start_time = stop_times_for_route[stop_times_for_route['planned_departure_time_from_origin'] >= start_time]
        
        # Get the unique trips from the sorted stop times after H
        unique_trips_after_start_time = stop_times_after_start_time['trip_id'].unique()
        
        # Select the first N trips
        selected_trips.extend(unique_trips_after_start_time[:nbr_buses_per_route_id])

    # Step 3: Filter trips.txt to keep only the selected trips
    final_trips_df = trips_df[trips_df['trip_id'].isin(selected_trips)]

    # Step 4: Filter stop_times_upgrade.txt to keep only stop times for the selected trips
    final_stop_times_df = stop_times_df[stop_times_df['trip_id'].isin(selected_trips)]

    # Step 5: Get the unique stop_ids from the filtered stop times
    selected_stop_ids = final_stop_times_df['stop_id'].unique()

    # Step 6: Filter stops.txt to keep only the stops in the selected trips
    final_stops_df = stops_df[stops_df['stop_id'].isin(selected_stop_ids)]

    # Create output directory
    output_path = os.path.join(base_path, f"{date}-TestInstance")
    os.makedirs(output_path, exist_ok = True)

    # Save output files
    final_trips_df.to_csv(os.path.join(output_path, "trips.txt"), index=False)
    final_stop_times_df.to_csv(os.path.join(output_path, "stop_times_upgrade.txt"), index=False)
    final_stops_df.to_csv(os.path.join(output_path, "stops.txt"), index=False)

def filter_connections(input_path, output_path, selected_stop_ids):
    """
    Filter available_connections.json based on the selected stop_ids.
    The filtered connections are saved in a new available_connections.json file.

    Inputs:
    - input_path: the path to the input directory containing available_connections.json
    - output_path: the path to the output directory where the new available_connections.json will be saved
    - selected_stop_ids: a list of selected stop_ids to keep in the available connections
    """

    available_connections_path = os.path.join(input_path, "available_connections.json")

    # Load available_connections.json and filter based on selected stop_ids
    with open(available_connections_path, 'r') as f:
        available_connections = json.load(f)

    filtered_connections = []
    for connection in available_connections:
        # Keep only the stops that are in the selected stop_ids
        filtered_connection = [stop_id for stop_id in connection if stop_id in selected_stop_ids]
        # Add the filtered connection if it still has more than one stop
        if len(filtered_connection) > 1:
            filtered_connections.append(filtered_connection)

    # Save the new available_connections.json
    output_connections_path = os.path.join(output_path, "available_connections.json")
    with open(output_connections_path, 'w') as f:
        json.dump(filtered_connections, f, indent=4)

def filter_requests(date, selected_trip_ids, base_path=os.path.join(os.path.dirname(__file__), '..', '..', 'data', 'fixed_line', 'gtfs')):
    """
    Filter requests.csv based on the selected bus trip_ids.
    The filtered requests are saved in a new filtered_requests.csv file.

    Inputs:
    - date: the date for which to generate the test instance (format: "YYYY-MM-DD")
    - selected_trip_ids: a list of selected bus trip_ids to keep in the requests
    - base_path: the base path where the GTFS files are stored

    Outputs:
    - filtered_requests.csv: a new CSV file containing the filtered requests
    """
    # Load input files
    input_path = os.path.join(base_path, date)
    requests_path = os.path.join(input_path, "requests.csv")

    # Load requests.csv into dataframe
    requests_df = pd.read_csv(requests_path, sep=';')

    # Step 1: Filter requests that have at least one leg with a selected trip_id
    filtered_requests = []
    for _, row in requests_df.iterrows():
        legs = ast.literal_eval(row['legs'])  # Convert string representation of list to actual list
        filtered_legs = [leg for leg in legs if leg[2] in selected_trip_ids]
        
        # If there is at least one leg with a selected trip_id, update the request
        if filtered_legs:
            if len(filtered_legs) == len(legs):
                # Keep the request as is if all legs are selected
                filtered_requests.append(row)
            elif len(filtered_legs) == 1:
                # Update the request if only one leg is kept
                row['origin'] = filtered_legs[0][0]
                row['destination'] = filtered_legs[0][1]
                row['legs'] = str([filtered_legs[0]])
                filtered_requests.append(row)
            elif len(filtered_legs) == 2:
                # Check if the two legs are consecutive
                if filtered_legs[0][1] == filtered_legs[1][0]:
                    # Update the request to keep the consecutive legs
                    row['origin'] = filtered_legs[0][0]
                    row['destination'] = filtered_legs[1][1]
                    row['legs'] = str(filtered_legs)
                    filtered_requests.append(row)
                # Remove the request if the first and last leg were kept (not consecutive)

    # Create a new dataframe with the filtered requests
    filtered_requests_df = pd.DataFrame(filtered_requests)

    # Create output directory
    output_path = os.path.join(base_path, f"{date}-TestInstance")
    os.makedirs(output_path, exist_ok=True)

    # Save the filtered requests to a new CSV file
    output_requests_path = os.path.join(output_path, "requests.csv")
    filtered_requests_df.to_csv(output_requests_path, sep=';', index=False)

    # print("Requests filtering complete. Output file generated:")
    print(f"- {output_requests_path}")

if __name__ == "__main__":
    date = "2019-11-01"
    start_time = 20000
    nbr_buses_per_route_id = 20

    #Define the route_ids to plot
    # Route ids for a quadrant style network
    route_ids = ['24E', '17S', '151S', '56E', '42E']

    generate_test_instance('gtfs'+date, route_ids, start_time, nbr_buses_per_route_id)

    #Route ids for a radial style network
    route_ids = ['70E', '31S', '37S', '39S', '33S']

    generate_test_instance('gtfs'+date, route_ids, start_time, nbr_buses_per_route_id)